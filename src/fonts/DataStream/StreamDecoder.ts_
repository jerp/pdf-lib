// Simple Stream Encoder base on ArrayBuffer
// inspiered by https://github.com/foliojs/restructure/blob/master/src/Decoder.coffee
// make this based on ArrayBuffer rather than Buffer
import { Int16View, Uint16View, Uint32View, Int8View, Int32View } from 'fonts/DataStream/views'

export class StreamDecoder {
  private view: DataView
  private data: Uint8Array
  offset: number
  constructor(data: Uint8Array) {
    this.view = new DataView(data.buffer)
    this.data = data
    this.offset = 0
  }
  // Uint8
  getUint8() {
    return this.view.getUint8(this.offset++)
  }
  // Uint16
  getUint16(littleEndian?: boolean) {
    const value = this.view.getUint16(this.offset, littleEndian)
    this.offset += 2
    return value
  }
  // Uint32
  getUint32(littleEndian?: boolean) {
    const value = this.view.getUint32(this.offset, littleEndian)
    this.offset += 4
    return value
  }
  // Int8
  getInt8() {
    return this.view.getInt8(this.offset++)
  }
  // Int16
  getInt16(littleEndian?: boolean) {
    const value = this.view.getInt16(this.offset, littleEndian)
    this.offset += 2
    return value
  }
  // Int32
  getInt32(littleEndian?: boolean) {
    const value = this.view.getInt32(this.offset, littleEndian)
    this.offset += 4
    return value
  }
  // Int32 with fixed decimal
  getFixed32() {
    return this.getInt32() / 0x10000
  }
  // UInt24
  getUint24(littleEndian?: boolean) {
    const value = littleEndian ? this.getUint16(true) + (this.getUint8() << 16) : (this.getUint16() << 8) + this.getUint8()
    return value
  }
  // Int24
  getInt24(littleEndian?: boolean) {
    // const value = littleEndian ?  this.getInt16(true) + (this.getInt8() << 16) : (this.getInt16() << 8) + this.getInt8()
    // this.offset += 3
    const uInt24 = this.getUint24(littleEndian)
    return uInt24 < 0x800000 ? uInt24 : (uInt24 - 0xffffff -1)
  }
  // Float32
  getFloat32(littleEndian?: boolean) {
    const value = this.view.getFloat32(this.offset, littleEndian)
    this.offset += 4
    return value
  }
  // Float64
  getFloat64(littleEndian?: boolean) {
    const value = this.view.getFloat64(this.offset, littleEndian)
    this.offset += 8
    return value
  }
  getString(byteLength: number, encoding: string | void = 'ascii') {
    switch (encoding) {
      case 'utf16le': case 'ucs2':
        return this.getUtf16(byteLength, true);
      case 'utf8':
        return this.getUtf8(byteLength);
      case 'ascii':
        return this.getAscii(byteLength);
      case 'utf16be':
        return this.getUtf16(byteLength)
      default:
        // TODO: check whne this is required
        // require('iconv-lite')
        // ...
        throw new Error('Install iconv-lite to enable additional string decodings.');
    }
  }
  private getAscii(byteLength: number) {
    const chars: string[] = []
    const end = this.offset + byteLength
    for (let i = this.offset; i < end; ++i) {
      chars.push(String.fromCharCode(this.view.getUint8(i)))
    }
    this.offset += byteLength
    return chars.join('')
  }
  private getUtf16(byteLength: number, littleEndian?: boolean) {
    const chars: string[] = []
    const end = this.offset + byteLength
    for (let i = this.offset; i < end; i += 2) {
      chars.push(String.fromCharCode(this.view.getUint16(i, littleEndian)))
    }
    this.offset += byteLength
    return chars.join('')
  }
  private getUtf8(byteLength: number) {
    const chars: string[] = []
    let i = this.offset
    const end = this.offset + byteLength
    let c: number
    while (i < end) {
      c = this.view.getUint8(i++);
      if (c > 127) {
        if (c > 191 && c < 224) {
          if (i >= end)
            throw new Error('UTF-8 decode: incomplete 2-byte sequence');
          c = (c & 31) << 6 | this.view.getUint8(i++) & 63;
        } else if (c > 223 && c < 240) {
          if (i + 1 >= end)
            throw new Error('UTF-8 decode: incomplete 3-byte sequence');
          c = (c & 15) << 12 | (this.view.getUint8(i++) & 63) << 6 | this.view.getUint8(i++) & 63;
        } else if (c > 239 && c < 248) {
          if (i + 2 >= end)
            throw new Error('UTF-8 decode: incomplete 4-byte sequence');
          c = (c & 7) << 18 | (this.view.getUint8(i++) & 63) << 12 | (this.view.getUint8(i++) & 63) << 6 | this.view.getUint8(i++) & 63;
        } else throw new Error('UTF-8 decode: unknown multibyte start 0x' + c.toString(16) + ' at index ' + (i - 1));
      }
      if (c <= 0xffff) chars.push(String.fromCharCode(c));
      else if (c <= 0x10ffff) {
        c -= 0x10000;
        chars.push(String.fromCharCode(c >> 10 | 0xd800))
        chars.push(String.fromCharCode(c & 0x3FF | 0xdc00))
      } else {
        throw new Error('UTF-8 decode: code point 0x' + c.toString(16) + ' exceeds UTF-16 reach')
      };
    }
    this.offset += byteLength
    return chars.join('');
  }
  getBytes(byteLength: number) {
    return this.data.subarray(this.offset, this.offset += byteLength)
  }
  getInt8View(length: number) {
    return new Int8View(this, length)
  }
  getUint16View(length: number, littleEndian?: boolean) {
    return new Uint16View(this, length, littleEndian)
  }
  getInt16View(length: number, littleEndian?: boolean) {
    return new Int16View(this, length, littleEndian)
  }
  getUint32View(length: number, littleEndian?: boolean) {
    return new Uint32View(this, length, littleEndian)
  }
  getInt32View(length: number, littleEndian?: boolean) {
    return new Int32View(this, length, littleEndian)
  }
  getView(byteLength: number) {
    const dataView = new DataView(this.data.buffer, this.offset, byteLength)
    this.offset += byteLength
    return dataView
  }
  getTypedArray(length: number, typedArrayClass: any): (Uint16Array | Int16Array | Int8Array | Uint8Array | Uint32Array | Int32Array) {
    // const byteLength = typedArrayClass.BYTES_PER_ELEMENT * length
    // return new typedArrayClass(this.data.buffer, this.offset, this.offset += byteLength)
    const typedArray = new typedArrayClass(this.data.buffer, this.offset, length)
    this.offset += typedArrayClass.BYTES_PER_ELEMENT * length
    return typedArray
  }
}
